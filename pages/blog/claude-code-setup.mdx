import { BlogPostLayout } from "../../components/BlogPostLayout";

<BlogPostLayout
  title="Claude Code: Setup and Learnings after 8 months of Usage"
  date="2026/1/26"
  tags={["AI", "tooling"]}
>

## My CC Journey and Usage

Coming from a traditional coding background, it is hard to let go of exact line by line control of the code.  
However, **for me code was always just about having a working product which solves a problem. As long as the product meets the requirement, the exact implementation details are secondary.**

So what am I even using Claude Code for at the moment? Classic Fullstack Development tasks:

- Frontend features
- Backend features
- DevOps tasks (CI/CD, Infrastructure as Code)
- Documentation (both for humans and Agents)
- Debugging (checking logs)
- Testing (unit tests, integration tests, e2e tests with Playwright)
- One-off data analysis, processing and crawling
- Project Management (writing and refining issues and PRs)

Until July 2025 I have been mostly using AI Coding Assistance via Cursor before switching to Claude Code.  
Having it purely in the Terminal felt alien and not part of my regular workflow. The gamechanger was once I had it within VS Code via the Claude extension and by getting direct diffs in the editor. That made it much easier to verify and understand the changes.

## General notes and observations

- Plan Mode is strong for complex changes and aligning expectations. Claude often correctly identifies architectural decisions and provides a handy list of the options.
- Use CC to commit and commit often. This is additional context for you **and** Claude. Especially when debugging, the commit history with good messages is a important data point.
- Let Claude use the CLI commands of your tools. e.g. the GH CLI for checking out issues and PRs works really well. IMO CLIs > MCP
- I didnt try Claude Cowork excessively. Currently I think it's good for one-off tasks which require desktop access. Letting it search for an invoice in my inbox or setting up email filter rules worked, but was not seamless.  
  For repeatable tasks, I'd prefer having scripts and reliable automation instead. That's cheaper and faster.
  With that said, I think Claude Code is similarly capable in non-coding tasks. I recently wrote a whole business plan with financial planning for a government grant application using Claude Code in VS Code. It worked really well using Markdown files and in the end creating PDF and Excel files. Software Engineering tooling like git and markdown is also perfect for this.
- I think the bigger a codebase gets, the more context Claude will need to gather to understand logical dependencies. We also build increasingly more abstractions and tests. This overall leads to more inference time and requires more tokens as for smaller codebases. So I think for larger codebases, the session limits will be hit more often.

## Claude Code Extension vs. CLI

I am using the VS Code extension exclusively.

Good:

- better image copy-pasting and image preview
- Handy button to start a new session
- better diffs view
- better session history access

Bad:

- No direct access to memory functionality (via `#`)
- Just a hunch, but I think the extension crashed the VS Code UI 3-4 times so far

## Boilerplates > Starting from Scratch

IMO Claude Code is not great at bootstrapping projects from scratch. Depending on the goal of the project, I either use the next.js init or my own vite boilerplate.  
This way I have my standard stack (React, useQuery, shadcn, tailwind, typescript, eslint etc.) set up correctly and Claude doesnt have to guess and waste tokens to figure out how to configure these things. Mainstream and modern libraries have the most surface area in the training of the model, so Claude will be more familiar with them and yield better results.

## What should be in your CLAUDE.md?

Foremost: Document whatever you find yourself explaining and repeating to the model.

Good candidates for this are:

- What the software is about, what's the business domain and bigger picture we want to achieve
- How to start the dev server
- How to build and test UI features
- Naming conventions
- Further documentation

The last one is important. This is essentially giving Claude the skill to find in-depth information for specific topics. I typically have in-depth documentation both for humans and Agents in Markdown files in the code base. I reference them with a short summary in CLAUDE.md so Claude knows where to look for more information.

Also, I state in the CLAUDE.md that we change any tech details, we need to update the respective markdown files around it too. Trying to keep these in sync is important.

## Subagents: UI-Validator + Playwright MCP

## Classic Dev Practices (lint, format, ...) help Claude Code too!

I have prettier and ESLint set up on all my projects. In some projects also unit tests.
With husky pre-commit hooks, we can ensure that new generated code from Claude is checked for our standards. In case of issues, Claude can directly fix the code before committing.

These rules can be quite custom like having at maximum 1.000 lines of code within one file. Having these checked deterministically is great as it will force Claude to adhere. This wouldnt be the case for writing it to CLAUDE.md.

## Skills

Skills are a simple way to extend Claude Code with specific task definitions and handy quick access via the slash `/` selector.

- `/handoff`: Summarize current Claude Session, start a new one and paste summary as context into the new session
- `/commit`: Commit changes (with pre-commit checks, groups changes logically, commits in logical groups with message convention)
- `/review`: Review and highlight code changes in feature branch vs. current dev branch

## Minor tweaks

### Using hooks

Claude Code has extensive support for custom hooks to interact with the Claude Code lifecycle.

The only hook I am actively using is a notification hook on `Stop`. It plays a completion sound once the prompt is done.

<CodeTabs tabs={["completion-sound.sh", "settings.json"]}>
```sh
#!/bin/bash

# Claude Code completion sound hook

# Plays a sound when Claude finishes a task

SOUND_FILE="/Users/YOUR_NAME/.claude/sounds/sound.m4a"

# Check if sound file exists

if [[-f "$SOUND_FILE"]]; then # Use afplay (macOS) to play the sound file
afplay "$SOUND_FILE" &
else
echo "Sound file not found: $SOUND_FILE" >&2
fi

````

```json
"hooks": {
  "Stop": [
    {
      "matcher": "*",
      "hooks": [
        {
          "type": "command",
          "command": "/Users/YOUR_NAME/.claude/hooks/completion-sound.sh"
        }
      ]
    }
  ]
}
```

</CodeTabs>

### Extra Repo Clones for parallel prompting

When working on multiple features in parallel, I usually create extra clones of the repository. You might find yourself working in multiple CC sessions in the same repo and this works ok as long as the changes are not overlapping. But this can get tricky fast.

I usually work on one bigger features requiring planning and longer edits at a time. In the other directory (i.e. separate branch), I do a couple smaller features. By keeping separate clones, I avoid confusion and overlapping changes.

(you can achieve the same effect by using git worktrees)

### Using tmux sessions

Claude will try to run the dev server too. It can be annoying having Claude run it, as it is hidden as a background process. I am also working in various sessions and this will lead to lost context within the logs if not all sessions can easily access the localhost for the API and Frontend logs.

I've recently started using tmux sessions to start the dev server in a dedicated terminal window. This way I can always see the logs and interact with the server if needed. In the CLAUDE.md, I specify that the dev server is running in a tmux session and that Claude can access it for local debugging and validation.

For projects where I have multiple clones, I specify a port in the environment variables to let Claude know which localhost to use for starting the server and attaching the tmux session.

```package.json
...
"scripts": {
    "dev:tmux": "PORT=$(grep -s '^DEV_PORT=' .env.local | cut -d= -f2 || echo 3000); PORT=${PORT:-3000} && SESSION=blog-$PORT && (tmux has-session -t $SESSION 2>/dev/null && echo \"Attaching to existing session $SESSION\" && tmux attach -t $SESSION) || (echo \"Starting new session $SESSION on port $PORT\" && tmux new-session -d -s $SESSION -n 'Blog Dev' \"PORT=$PORT NEXT_PUBLIC_SITE_URL=http://localhost:$PORT yarn dev\" && tmux attach -t $SESSION)",
  }
...
```

In ClAUDE.md:

```markdown
## Development Server
- Start dev server: `yarn dev:tmux` (creates/attaches to tmux session)
- Port is configured via `DEV_PORT` env variable (default: 3000)
- Session name: `blog-{PORT}` (e.g., `blog-3000`)
- To check dev server output: `tmux capture-pane -t blog-$DEV_PORT -p -S -50`
- To attach to the session: `tmux attach -t blog-$DEV_PORT`
- For multiple instances (different directories), set different `DEV_PORT` in each `.env.local`
- **UI Validator agent**: Use `http://localhost:$DEV_PORT` (check `DEV_PORT` in `.env.local`, default 3000)
```

### ClaudeBar for tracking sessions
I am using [ClaudeBar](claudebar.png), nice overview of current sessions and weekly limit. Also shows a quick indicator already in the menu bar.

## Further Reading

There is a lot of noise in the AI Coding field. My favorite sources around this (and more) are Boris Cherny and Simon Willison.

</BlogPostLayout>
````
