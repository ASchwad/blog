import { BlogPostLayout } from "../../components/BlogPostLayout";

<BlogPostLayout
  title="Getting Started with Claude Code"
  date="2026/1/26"
  tags={["AI", "tooling"]}
>

## My CC Journey and Usage

Coming from a traditional coding background, it is hard to let go of exact line by line control of the code.
However, **for me code was always just about having a working product which solves a problem. As long as the product meets the requirement, the exact implementation details are secondary.** With AI Coding (not just CC but also Codex, OpenCode, Cursor, ...) The bottleneck of software engineering is understanding markets / business requirements and validating the implementation against these requirements.

So what am I using Claude Code for at the moment? Still classic Fullstack Development tasks:

- Frontend features
- Backend features
- LLM Prompt tuning for AI-centered software
- DevOps tasks (CI/CD, Infrastructure as Code)
- Documentation (both for humans and Agents)
- Debugging (checking logs)
- Testing (unit tests, integration tests, e2e tests with Playwright)
- One-off data analysis, processing and crawling
- Project Management (writing and refining issues and PRs)

Where am I **not** using Claude Code? Only really in validating ideas and showing new features to customers. Still wondering how I could leverage it more here

Until July 2025 I have been mostly using AI Coding Assistance via Cursor before switching to Claude Code.
Having it purely in the Terminal felt alien and not part of my regular workflow. The gamechanger was once I had it within VS Code via the Claude extension and by getting direct diffs in the editor. That made it much easier to verify and understand the changes.

![My token consumption over time](/images/blog/claude-code-setup/image.png)

## Boilerplates > Starting from Scratch

IMO Claude Code is not great at bootstrapping projects from scratch. Depending on the goal of the project, I either use the next.js init or my own vite boilerplate.
This way I have my standard stack (React, useQuery, shadcn, tailwind, typescript, eslint etc.) set up correctly and Claude doesnt have to guess and waste tokens to figure out how to configure these things. Mainstream and modern libraries have the most surface area in the training of the model, so Claude will be more familiar with them and yield better results.

## What should be in your CLAUDE.md?

Foremost: Document whatever you find yourself explaining and repeating to the model.

Good candidates for this are:

- What the software is about, what's the business domain and bigger picture we want to achieve
- How to start the dev server
- How to build and test UI features
- Naming conventions
- Further documentation

The last one is important. This is essentially giving Claude the skill to find in-depth information for specific topics. I typically have in-depth documentation both for humans and Agents in Markdown files in the code base. I reference them with a short summary in CLAUDE.md so Claude knows where to look for more information.

Also, I state in the CLAUDE.md that we change any tech details, we need to update the respective markdown files around it too. Trying to keep these in sync is important.

## Classic Dev Practices (lint, format, ...) help Claude Code too!

I have prettier and ESLint set up on all my projects. In some projects also unit tests.
With husky pre-commit hooks, we can ensure that new generated code from Claude is checked for our standards. In case of issues, Claude can directly fix the code before committing.

These rules can be quite custom like having at maximum 1.000 lines of code within one file. Having these checked deterministically is great as it will force Claude to adhere. This wouldnt be the case for writing it to CLAUDE.md.

## Further Reading

There is a lot of noise in the AI Coding field. My favorite sources around this (and more) are [Boris Cherny](https://x.com/bcherny) and [Simon Willison](https://simonwillison.net/).

</BlogPostLayout>
